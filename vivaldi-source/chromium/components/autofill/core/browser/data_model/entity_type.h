// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_ENTITY_TYPE_H_
#define COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_ENTITY_TYPE_H_

#include <ostream>
#include <string_view>

#include "base/containers/span.h"
#include "components/autofill/core/browser/data_model/entity_type_names.h"
#include "components/autofill/core/browser/field_types.h"
#include "components/autofill/core/common/dense_set.h"

namespace autofill {

// Entity and attribute types are blueprints for entity and attribute instances.
//
// For example, "passport" is an entity type and its attribute types include
// "name", "country", "issue date", "expiry date", etc.
//
// A specific passport is an entity instance, which has attribute instances with
// values such "John Doe", "USA", "05/2019", "04/2029", etc.
//
// Entity types are generated at compile time from the schema definition in
// entity_schema.json.
class EntityType;
class AttributeType;

// Customization point for mapping attributes to FieldTypes.
// For example, a the "name" attribute type of a passport or identity card may
// be mapped to NAME_FULL.
FieldType AttributeTypeNameToFieldType(AttributeTypeName a);

// An attribute type is the blueprint for an attribute instance, which in turn
// represents a string value with additional metadata.
//
// An AttributeType is uniquely identified by its AttributeTypeName from
// entity_type_names.h generated by transpile_entity_schema.py. AttributeType is
// merely a thin wrapper with member functions.
class AttributeType final {
 public:
  // Returns `std::nullopt` if `type` cannot be mapped to any `AttributeType`.
  static std::optional<AttributeType> FromFieldType(FieldType type);

  // Defines ordering for disambiguating different instances of the same entity
  // type, as specified in the schema.
  // "Less" according to this ordering means "higher precedence".
  //
  // For example, when disambiguating different passport instances, the name and
  // country should likely take precedence over the passport number.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  struct DisambiguationComparator {
    bool operator()(const AttributeType& lhs, const AttributeType& rhs) const;
  };

  constexpr explicit AttributeType(AttributeTypeName n) : name_(n) {}

  constexpr AttributeType(const AttributeType&) = default;
  constexpr AttributeType& operator=(const AttributeType&) = default;
  constexpr AttributeType(AttributeType&&) = default;
  constexpr AttributeType& operator=(AttributeType&&) = default;

  constexpr AttributeTypeName name() const { return name_; }

  EntityType entity_type() const;

  // The FieldType associated with this attribute as defined in
  // AttributeTypeNameToFieldType().
  FieldType field_type() const { return AttributeTypeNameToFieldType(name_); }

  // The string representation of the name. This is unique among all attribute
  // types of the associated entity type. (It is not globally unique!)
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  std::string_view name_as_string() const;

  friend constexpr bool operator==(const AttributeType& lhs,
                                   const AttributeType& rhs) = default;

 private:
  AttributeTypeName name_{};
};

template <>
struct DenseSetTraits<AttributeType> {
  using T = AttributeType;
  using N = AttributeTypeName;
  using UnderlyingType = std::underlying_type_t<N>;

  static constexpr T from_underlying(UnderlyingType x) {
    return T(static_cast<N>(x));
  }
  static constexpr UnderlyingType to_underlying(T x) {
    return base::to_underlying(x.name());
  }

  static constexpr auto kMinValue = T(static_cast<N>(0));
  static constexpr auto kMaxValue = T(N::kMaxValue);
  static constexpr bool kPacked = false;
};

// An entity type is the blueprint for an entity instance. It defines the
// available attributes and additional metadata.
//
// An EntityType is uniquely identified by its EntityTypeName from
// entity_type_names.h generated by transpile_entity_schema.py. EntityType is
// merely a thin wrapper with member functions.
class EntityType final {
 public:
  constexpr explicit EntityType(EntityTypeName n) : name_(n) {}

  constexpr EntityType(const EntityType&) = default;
  constexpr EntityType& operator=(const EntityType&) = default;
  constexpr EntityType(EntityType&&) = default;
  constexpr EntityType& operator=(EntityType&&) = default;

  constexpr EntityTypeName name() const { return name_; }

  // The string representation of the name. This is unique among all entity
  // types.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  std::string_view name_as_string() const;

  // The attributes supported by this entity type, as specified in the schema.
  // An instance of this entity may define values for some or all of these
  // attributes.
  //
  // For example, for a passport entity this may be the number, the name, the
  // country etc.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  DenseSet<AttributeType> attributes() const;

  // An import constraint is a precondition for importing an EntityInstance on
  // form submission: it is a set of attributes all of which the instance must
  // set.
  // At least one of the import constraints must be satisfied.
  //
  // For example, for a passport the import constraints may be {number} and
  // {name, country}. Then it suffices for an instances to define either the
  // number or both the name and country.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  base::span<const DenseSet<AttributeType>> import_constraints() const;

  // A merge constraint is a precondition for merging two EntityInstances: it is
  // a set of attributes which both instances must agree on, i.e., they must set
  // it to the same value.
  // At least one of the merge constraints must be satisfied.
  //
  // Intuitively, the attributes of a merge constraint uniquely identify an
  // entity instances.
  //
  // For example, for a passport the two alternative constraints may be {number}
  // and {name, country, issue date} because passport numbers generally serve
  // as unique identifiers and also a single user usually only has one passport
  // per name, country, and date.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  base::span<const DenseSet<AttributeType>> merge_constraints() const;

  // Indicates if instances of this type may be synced, as specified in the
  // schema.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  bool syncable() const;

  friend constexpr bool operator==(const EntityType& lhs,
                                   const EntityType& rhs) = default;

 private:
  EntityTypeName name_{};
};

// Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
bool IsValidEntityTypeName(EntityTypeName t);
bool IsValidAttributeTypeName(AttributeTypeName a);
EntityTypeName AttributeTypeNameToEntityTypeName(AttributeTypeName a);

std::ostream& operator<<(std::ostream& os, AttributeType a);
std::ostream& operator<<(std::ostream& os, EntityType t);

}  // namespace autofill

#endif  // COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_ENTITY_TYPE_H_
