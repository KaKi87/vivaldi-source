diff --git a/tools/webtransport/h3/webtransport_h3_server.py b/tools/webtransport/h3/webtransport_h3_server.py
index 2dd8f645551d6..8c55ba87e0e59 100644
--- a/tools/webtransport/h3/webtransport_h3_server.py
+++ b/tools/webtransport/h3/webtransport_h3_server.py
@@ -1,7 +1,6 @@
 # mypy: allow-subclassing-any, no-warn-return-any

 import asyncio
-import contextlib
 import logging
 import os
 import ssl
@@ -10,21 +9,17 @@ import threading
 import traceback
 from enum import IntEnum
 from urllib.parse import urlparse
-from typing import Any, Dict, List, Optional, Tuple, cast
+from typing import Any, Dict, List, Optional, Tuple

 # TODO(bashi): Remove import check suppressions once aioquic dependency is resolved.
 from aioquic.buffer import Buffer  # type: ignore
 from aioquic.asyncio import QuicConnectionProtocol, serve  # type: ignore
 from aioquic.asyncio.client import connect  # type: ignore
-from aioquic.asyncio.protocol import QuicStreamAdapter  # type: ignore
 from aioquic.h3.connection import H3_ALPN, FrameType, H3Connection, ProtocolError, SettingsError  # type: ignore
 from aioquic.h3.events import H3Event, HeadersReceived, WebTransportStreamDataReceived, DatagramReceived, DataReceived  # type: ignore
 from aioquic.quic.configuration import QuicConfiguration  # type: ignore
 from aioquic.quic.connection import logger as quic_connection_logger  # type: ignore
-from aioquic.quic.connection import (
-    stream_is_client_initiated,
-    stream_is_unidirectional,
-)
+from aioquic.quic.connection import stream_is_unidirectional
 from aioquic.quic.events import QuicEvent, ProtocolNegotiated, ConnectionTerminated, StreamReset  # type: ignore
 from aioquic.tls import SessionTicket  # type: ignore

@@ -415,7 +410,7 @@ class WebTransportSession:
             _logger.warn(
                 "Sending a datagram while that's now allowed - discarding it")
             return
-        stream_id = self.session_id
+        flow_id = self.session_id
         if self._http.datagram_setting is not None:
             # We must have a WebTransport Session ID at this point because
             # an extended CONNECT request is already received.
@@ -423,8 +418,8 @@ class WebTransportSession:
             # TODO(yutakahirano): Make sure if this is the correct logic.
             # Chrome always use 0 for the initial stream and the initial flow
             # ID, we cannot check the correctness with it.
-            stream_id = self._protocol._session_stream_id
-        self._http.send_datagram(stream_id=stream_id, data=data)
+            flow_id = self._protocol._session_stream_id // 4
+        self._http.send_datagram(flow_id=flow_id, data=data)

     def stop_stream(self, stream_id: int, code: int) -> None:
         """
@@ -607,25 +602,6 @@ async def _connect_server_with_timeout(host: str, port: int, timeout: float) ->
     return True


-def _close_unusable_writer(reader: asyncio.StreamReader, writer: asyncio.StreamWriter) -> None:
-    # Starting in python3.11, `StreamWriter.__del__` implicitly `close()`s
-    # itself [0], if it has not done so already. Because aioquic sometimes
-    # models a unidirectional stream with a bidirectional transport [1], the
-    # `writer` here for a server -> client stream may log a benign but
-    # scary-looking exception when it's GC'ed and unsuccessfully writes EOF.
-    #
-    # For the purpose of checking connectivity, work around this for now by
-    # preemptively closing such streams and suppressing the resulting
-    # exceptions.
-    #
-    # [0]: https://github.com/python/cpython/blob/3.11/Lib/asyncio/streams.py#L413
-    # [1]: https://github.com/aiortc/aioquic/blob/1.2.0/src/aioquic/asyncio/protocol.py#L241
-    stream_id = cast(QuicStreamAdapter, writer.transport).stream_id
-    if stream_is_unidirectional(stream_id) and not stream_is_client_initiated(stream_id):
-        with contextlib.suppress(ValueError):
-            writer.close()
-
-
 async def _connect_to_server(host: str, port: int) -> None:
     configuration = QuicConfiguration(
         alpn_protocols=H3_ALPN,
@@ -633,6 +609,5 @@ async def _connect_to_server(host: str, port: int) -> None:
         verify_mode=ssl.CERT_NONE,
     )

-    async with connect(host, port, configuration=configuration,
-                       stream_handler=_close_unusable_writer) as protocol:
+    async with connect(host, port, configuration=configuration) as protocol:
         await protocol.ping()
